#Lab2
### 计23 徐梓哲 2012011487
###0.
使用vimdiff手动修改即可

###1.

我们需要从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。

代码分析在注释中。

改进：如果时间允许的话（也就是在CPU等空闲的时候），可以转移内存的数据，使得空闲的区域连在一起。


###2.

通过虚拟地址对应的叶表项的过程在书上有描述。
	
	#define PTE_P           0x001                   // 是否使用中，已用于页机制中。
	#define PTE_W           0x002                   // 是否可写，已用于页机制中。
	#define PTE_U           0x004                   // 用户态使用，用于用户态管理。
	#define PTE_PWT         0x008                   // 是否写直达，用于cache的写回。
	#define PTE_PCD         0x010                   // 禁用cache，用于cache系统。
	#define PTE_A           0x020                   // 是否被访问过
	#define PTE_D           0x040                   // 脏位，被改写，用于write-back写回cache。
	#define PTE_PS          0x080                   // 页大小
	#define PTE_MBZ         0x180                   // 保留位，全部置0
	#define PTE_AVAIL       0xE00                   // 软件是否可以使用

发生错误时，首先去CR0~CR3寄存器查看保存异常的信息和当前的程序运行状态，然后通过idt找到对应地址并跳转执行处理异常的程序

###3.
有。
Page的全局变量就表示表项指示的物理地址页。

需要将KERN_BASE设为0x100000，即ucore的起始地址和内核虚地址要一样。
